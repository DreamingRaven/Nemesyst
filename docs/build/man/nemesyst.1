.\" Man page generated from reStructuredText.
.
.TH "NEMESYST" "1" "Jan 29, 2020" "" "Nemesyst"
.SH NAME
nemesyst \- Nemesyst 2.0.5.r81.ab07514
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
\fI\%Nemesyst Logo\fP.SH MIT LICENSE
.sp
Copyright (c) 2017 George Onoufriou (GeorgeRaven, archer, DreamingRaven)
.sp
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the “Software”), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.sp
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
.sp
THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
.SH WHY USE NEMESYST
.sp
Nemesyst is a highly configurable hybrid parallelization deep learning framework, for distributed deep learning, that uses other backend framework(s) of your choice (Pytorch, TensorFlow, etc.) for training.
.INDENT 0.0
.INDENT 2.5
[image: Nemesyst use-case example diagram.]
[image]
This image is a use case example of Nemesyst applied to a distributed refrigeration fleet over multiple sites, and both online and offline learning capabilities occuring simultaneously..UNINDENT
.UNINDENT
.sp
Nemesyst uses MongoDB as its core message passing interface (MPI). This means MongoDB is used to store, distribute, retrieve, and transform the data; store, distribute, and retrieve the trained models. In future we also hope to use it to transfer more specific processing instructions to individual learners. This way we use the already advanced functionality of MongoDB to handle complex and non\-trivial problems such as tracing models back to the specific data trained with, the results and arguments present at the point of training, and being able to reload pre\-trained models for further use, and, or training. This also means the same data can be transformed differently for different learners from the same source dynamically at the point of need.
.SH INSTALLATION
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Certain distributions link \fBpython\fP to \fBpython2\fP and others link it to \fBpython3\fP\&.
For disambiguation python, pip, and virtualenv shall mean their python v3 versions here, i.e. \fBpython3\fP, \fBpip3\fP, \fBvirtualenv3\fP\&.
.UNINDENT
.UNINDENT
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
You will need to have \fI\%git\fP, and \fI\%python\fP installed any of the below methods to work.
You will also need \fI\%MongoDB\fP if you intend to create a local database, (more than likely), but Nemesyst will still connect to already running databases without it if you happen to have one already.
.UNINDENT
.UNINDENT
.sp
This section will outline various methods for installation of Nemesyst, and its dependencies. Not all methods are equal there are slight variations between them, which are outlined in the respective sections below, along with instructions for each method:
.INDENT 0.0
.IP \(bu 2
\fI\%Files\-only/ development\fP
.INDENT 2.0
.IP \(bu 2
\fI\%Getting the files\fP
.IP \(bu 2
\fI\%Installing dependancies\fP
.UNINDENT
.IP \(bu 2
\fI\%Automated\fP
.INDENT 2.0
.IP \(bu 2
\fI\%Generic\fP
.IP \(bu 2
\fI\%Archlinux\fP
.UNINDENT
.IP \(bu 2
\fI\%Manual\fP
.INDENT 2.0
.IP \(bu 2
\fI\%Generic\fP
.IP \(bu 2
\fI\%Archlinux\fP
.UNINDENT
.IP \(bu 2
\fI\%Virtual env\fP
.UNINDENT
.SS Files\-only/ development
.sp
This method of files\-only installation provides the user with all the additional utility files, and examples needed during development. This includes the files necessary for the page_mnist, and is advised when first starting to use Nemesyst so that you can better understand what is going on. In production however you do not need all these additional files so other slimmer/ more streamlined methods of installation are better.
.INDENT 0.0
.INDENT 3.5
Pros:
.INDENT 0.0
.IP \(bu 2
All the example files for quickly getting to grips with Nemesyst.
.IP \(bu 2
Easy to understand as the files are not filed away somewhere obscure.
.IP \(bu 2
Easy to install example dependencies as you can \fBpip install \-r requirements.txt\fP or whatever other requirements list we include.
.IP \(bu 2
Unit tests available.
.UNINDENT
.sp
Cons:
.INDENT 0.0
.IP \(bu 2
You are responsible for ensuring the requirements are met for Nemesyst, such as \fI\%python\fP, \fI\%git\fP, and \fI\%MongoDB\fP\&.
.IP \(bu 2
It is less repeatable/ deployable as most steps are manual as opposed to the other available methods of installation.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Getting the files
.sp
To retrieve the Nemesyst files you will need \fI\%git\fP installed. To download the Nemesyst directory in your current working directory you can run:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git clone https://github.com/DreamingRaven/nemesyst
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Installing dependancies
.sp
To make use of Nemesyst directly now that you have the files you need to have installed:
.sp
System dependencies:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.IP 1. 3
\fI\%python\fP (required): Nemesyst is written in \fI\%python\fP, you wont get far without it.
.IP 2. 3
\fI\%git\fP (required): To install, and manage Nemesyst files.
.IP 3. 3
\fI\%MongoDB\fP (recommended): If you want to be able to create, and destroy a local \fI\%MongoDB\fP database.
.IP 4. 3
\fI\%Docker\fP (optional): If you want to manage local containerized \fI\%MongoDB\fP databases.
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Python dependencies:
.INDENT 0.0
.INDENT 3.5
.INDENT 0.0
.TP
.B \fB\&./nemesyst/requirements.txt\fP
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
ConfigArgParse>=0.14.0
pymongo>=3.8.0
future>=0.17.1

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You can install these quickly using:
.INDENT 7.0
.TP
.B \fI\%Bash shell\fP installing dependancies from file
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
pip install \-r \fB\&./nemesyst/requirements.txt\fP
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
or:
.INDENT 7.0
.TP
.B \fI\%Bash shell\fP installing Nemesyst and dependancies using setup.py
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
python setup.py install
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.sp
Optionally if you would like to build the Nemesyst documentation, and/ or use the full testing suite you will require \fB\&./nemesyst/docs/requirements.txt\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
sphinx>=2.1.2
sphinx\-argparse>=0.2.5
sphinx\-rtd\-theme>=0.4.3
ConfigArgParse>=0.14.0
pymongo>=3.8.0
future>=0.17.1

.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Automated
.sp
This section discusses the more automated and repeatable installation methods for Nemesyst, but they do not contain all the files needed to learn, and begin developing Nemesyst integrated applications, rather this includes just the bare\-bones Nemesyst ready for your deployment.
.SS Generic
.sp
For now you can use pip via:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pip install git+https://github.com/DreamingRaven/nemesyst.git#branch=master
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Archlinux
.sp
Install \fI\%nemesyst\-git\fP\s-2\uAUR\d\s0\&.
.SS Manual
.SS Generic
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git clone https://github.com/DreamingRaven/nemesyst
cd nemesyst
python setup.py install
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Archlinux
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git clone https://github.com/DreamingRaven/nemesyst
cd nemesyst/.arch/
makepkg \-si
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Virtual env
.sp
To create the \fI\%python\-virtualenv\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
vituralenv venv
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To then use the newly created virtual environment:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
source venv/bin/activate
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
OR if you are using a terminal like fish:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
source venv/bin/activate.fish
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To install Nemesyst and all its dependencies into a virtual environment while it is being used (activated):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
pip install git+https://github.com/DreamingRaven/nemesyst.git#branch=master
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
To exit the virtual environment:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
deactivate
.ft P
.fi
.UNINDENT
.UNINDENT
.SH OVERVIEW
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Throughout this overview and in certain other sections the examples provided are for section_files\-only installations, however this is only to make it easier to use the inbuilt examples/ sample files rather than having to force the user to define his/ her own cleaning, learning, infering scripts, for the sake of simplicity.
.sp
If you are not using the section_files\-only installation you will have to point nemesyst to cleaners, learners, predictors etc that you want to use. Although even if you are using section_files\-only, eventually once you have better understood and tested Nemesyst then you should likeley move to creating your own ones that you require, and using a normal installation of Nemesyst such as one of the section_automated examples.
.UNINDENT
.UNINDENT
.SS Nemesyst literal un\-abstract stages
.INDENT 0.0
.INDENT 2.5
[image: Nemesyst use-case example diagram.]
[image]
This image is a use case example of Nemesyst applied to a distributed refrigeration fleet over multiple sites, and both online and offline learning capabilities occuring simultaneously..UNINDENT
.UNINDENT
.sp
Nemesyst has been made to be generic enough to handle many possible configurations, but we cannot possibly handle all possible scenarios. Sometimes it may be necessary to manually configure certain aspects of the process, especially regarding MongoDB as it is quite a well developed, mature, database, with more features than we could, and should automate.
.SS Nemesyst Abstraction of stages
.INDENT 0.0
.INDENT 2.5
[image: Nemesyst stages of data from input to output.]
[image]
Nemesyst has abstracted, grouped, and formalised what we believe are the core stages of applying deep learning at all scales..UNINDENT
.UNINDENT
.sp
Deep learning can be said to include 3 stages, data\-wrangling, test\-training, and inferring. Nemesyst adds an extra layer we call serving, which is the stage at which databases are involved as the message passing interface (MPI), and generator, between the layers, machines, and algorithms, along with being the data, and model storage mechanism.
.SS Nemesyst Parallelisation
.sp
As of: \fI\%2.0.1.r6.f9f92c3\fP
.INDENT 0.0
.INDENT 2.5
[image: Nemesyst round depiction diagram, showing the order and values of rounds.]
[image]
Nemesyst parallelises each script, up the the maximum number of processes in the process pool..UNINDENT
.UNINDENT
.sp
Local parallelization of your scripts occur using pythons process pools from multiprocessing. This diagram shows how the rounds of processing are abstracted and the order of them. Rounds do not continue between stages, I.E if there is a spare process but not enough scripts from that stage (e.g cleaning) it will not fill this with a script process from the next stage (e.g learning). This is to prevent the scenario where a learning script may depend on the output of a previous cleaning script.
.SS Wrangling / cleaning
.sp
See section_all\-options for a full list of options.
.INDENT 0.0
.INDENT 2.5
[image: Nemesyst wrangling puzzle diagram.]
[image]
Wrangling is the stage where the data is cleaned into single atomic examples to be imported to the database..UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B section_files\-only example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
nemesyst

.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS Serving
.sp
See section_all\-options for a full list of options.
.INDENT 0.0
.INDENT 2.5
[image: Nemesyst database serving puzzle diagram.]
[image]
Serving is the stage where the data and eventually trained models will be stored and passed to other processess potentially on other machines..UNINDENT
.UNINDENT
.sp
Nemesyst uses MongoDB databases through \fI\%PyMongo\fP as a data store, and distribution mechanism. The database(s) are some of the most important aspects of the chain of processes, as nothing can operate without a properly functioning database. As such we have attempted to simplify operations on both the user scripts side and our side by abstracting the slightly raw \fI\%PyMongo\fP interface into a much friendlier class of operations called section_mongo\&.
.sp
A section_mongo object is automatically passed into every one of your desired scripts entry points, so that you can also easily operate on the database if you so choose although aside from our data generator we handle the majority of use cases before it reaches your scripts.
.INDENT 0.0
.TP
.B section_automated example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
# creating basic non\-config, non\-replica, localhost, mongodb instance
nemesyst \-\-db\-init \-\-db\-start \-\-db\-login \-\-db\-stop \e
         \-\-db\-user\-name USERNAME \-\-db\-password \e
         \-\-db\-path DBPATH \-\-db\-log\-path DBPATH/LOGDIR

.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Please see page_serving for more in depth serving with Nemesyst
.UNINDENT
.UNINDENT
.SS Learning
.sp
See section_all\-options for a full list of options.
.INDENT 0.0
.INDENT 2.5
[image: Nemesyst learning puzzle diagram.]
[image]
Learning is the stage where the data is used to train new models or to update an existing model already in the database..UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B section_files\-only example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
nemesyst

.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
Special attention should be paid to the size of the resultant neural networks. Beyond a certain size it will be necessary to store them as GridFS objects. The basic GridFS functionality is included in nemesyst’s section_mongo however this is still experimental and should not be depended upon at this time.
.UNINDENT
.UNINDENT
.SS Inferring / predicting
.sp
As of: \fI\%2.0.2.r7.1cf3eab\fP
.sp
See section_all\-options for a full list of options.
.INDENT 0.0
.INDENT 2.5
[image: Nemesyst inference puzzle diagram.]
[image]
Inferring is the stage where the model(s) are used to predict on newly provided data..UNINDENT
.UNINDENT
.INDENT 0.0
.TP
.B section_files\-only example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
nemesyst

.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SH FULL MNIST EXAMPLE
.sp
\fI\%MNIST\fP is a popular well known dataset for evaluating machine learning models. It has been effectively solved at this point, but it is still a good starting point for getting to know how Nemesyst works, and to be able to show people how to use Nemesyst in practice.
It is also relatively clean so there is little pre\-processing that is required other than turning it into a directly usable form.
.sp
The dataset will be downloaded for you by the cleaning module.
.SS Requirements
.sp
Please ensure you have both \fI\%MongoDB\fP and the following python dependencies installed as a bare minimum:
.INDENT 0.0
.TP
.B \fBexamples/requirements/mnist.txt\fP
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
ConfigArgParse>=0.14.0
pymongo>=3.8.0
future>=0.17.1
scikit\-learn>=0.21.3
keras>=2.3.1
tensorflow\-gpu>=2.0.0

.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
If you are using pip you can quickly install these using:
.INDENT 0.0
.TP
.B section_files\-only pip requirements installation example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
pip install \-r examples/requirements/mnist.txt
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Please also ensure you have the Nemesyst files at hand ( section_files\-only ) as they have all the extra files you will need later on, which are only present in section_files\-only
.UNINDENT
.UNINDENT
.SS Configuring
.sp
For this example we have created a configuration file for you so there is nothing additional that needs to be done. It is advised that you read it through. It is a \fI\&.ini\fP style file. However each of these options can be passed in to Nemesyst as cli or environment options as well but we believed it would be a much nicer introduction to have them in a configuration file.
.INDENT 0.0
.TP
.B \fBexamples/configs/nemesyst/mnist.conf\fP
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
# please see full documentation at:
#
# this config file assumes you are in the directory nemesyst from:
# https://github.com/DreamingRaven/nemesyst
# we use relative paths here so they may not work if you arent there.

# mongodb options for your experimental database
\-\-db\-user\-name=groot          # change this to you desired username
\-\-db\-password=True            # this will create a password prompt
; \-\-db\-init=True                # initialises the database with user
; \-\-db\-start=True               # starts the database
\-\-db\-port=65530               # sets the db port
\-\-db\-name=data                # sets the database name
\-\-db\-path=./data_db/          # sets the path to create a db
\-\-db\-log\-path=./data_db/      # sets the parent directory of log files
\-\-db\-log\-name=mongo_log       # sets the file name to use for log
\-\-db\-authentication=SCRAM\-SHA\-1 # sets db to be connected to using user/pass

# cleaning specific options
; \-\-data\-clean=True                                             # nothing will be cleaned unless you tell nemesyst to even if you give it the other information
\-\-data\-cleaner=examples/cleaners/mnist_cleaner.py             # the path to the cleaner in this case MNIST example cleaner
\-\-data\-collection=mnist                                       # sets the collection to import to

# learning specific options
; \-\-dl\-learn=True                                               # nothing will be learned unless you tell nemesyst explicitly to do so even if other information is given
\-\-dl\-learner=examples/learners/mnist_learner.py               # the path to the learner in this case MNIST example learner
\-\-dl\-batch\-size=32                                            # set the batch sizes to use
\-\-dl\-epochs=12                                                # set the number of epochs we want (times to train on the same data)
\-\-dl\-output\-model\-collection=models

# infering specific options
; \-\-i\-predict=True                                              # nothing will be predicted unless you tell nemesyst explicitly to do so even if other information is given
\-\-i\-predictor=examples/predictors/mnist_predictor.py          # the path to the predictor in this case MNIST example predictor

.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
If you would like to skip rest of this example for whatever reason such as you are more interested in checking Nemesyst is working simply remove the symbol “\fI;\fP” from the start of any lines it appears in to uncomment that line, and then run everything using:
.INDENT 0.0
.TP
.B section_files\-only automated example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
\&./nemesyst \-\-config ./examples/configs/nemesyst/mnist.conf
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS Serving
.sp
For this example Nemesyst will create a database for us whenever we call the config file since we pass in options to initialize and start the database (see \fI\%Configuring\fP). We can do this using:
.INDENT 0.0
.TP
.B section_files\-only serving example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
\&./nemesyst \-\-config ./examples/configs/nemesyst/mnist.conf \-\-db\-init \-\-db\-start
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
This example will start the database, to close the database you can:
.INDENT 0.0
.TP
.B section_files\-only stopping database example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
\&./nemesyst \-\-config ./examples/configs/nemesyst/mnist.conf \-\-db\-stop
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Nemesyst may ask you a password. As long as you are using the same password between runs it wont cause you issue as you are simultaneously using and creating (when using –db\-init) the password for the default user in our config file, you can change this behavior but we wanted to include it so we don’t end up creating universal passwords that lazy users might oversee.
.sp
For more complex scenarios pleas refer to page_serving
.UNINDENT
.UNINDENT
.SS Checking up on the database
.sp
It may be necessary after each of the following steps to check on the database to ensure it has done exactly what you expect it to be doing. To login to the database easily you can use:
.INDENT 0.0
.TP
.B section_files\-only logging into running database example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
\&./nemesyst \-\-config ./examples/configs/nemesyst/mnist.conf \-\-db\-login
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
This should put you in the \fI\%Mongo shell\fP which is a javascript based interface of \fI\%MongoDB\fP for direct user intervention. Where you can do all sorts of operations and checks. This is of course optional but recommended. If you would rather a more graphical interface you can use any of the plethora of tools to visualize the database but we recommend \fI\%MongoDB Compass\fP, in particular for its aggregation helper.
.SS Cleaning
.sp
In this step we will launch the example \fI\%MNIST\fP cleaner which downloads the data using \fI\%scikit\-learn\fP to get a much cleaner version of the data set for us. Then inserting the data into individual dictionaries row wise, so that each dictionary is a single complete example/ observation, with associated target feature. To put it back into the database we need only yield each dictionary and Nemesyst will handle iteration for us. This document dictionary can also be used to house useful metadata about the dataset so that you can further filter using more advanced Nemesyst and MongoDB functionality that go beyond the scope of this simple introduction.
.sp
To begin cleaning you need only tell Nemesyst to clean the data using:
.INDENT 0.0
.TP
.B section_files\-only cleaning example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
\&./nemesyst \-\-config ./examples/configs/nemesyst/mnist.conf \-\-data\-clean
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
The example \fI\%MNIST\fP cleaner is shown below for convenience.
.INDENT 0.0
.TP
.B \fBexamples/cleaners/mnist_cleaner.py\fP
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
# @Author: George Onoufriou <archer>
# @Date:   2019\-08\-15
# @Email:  george raven community at pm dot me
# @Filename: debug_cleaner.py
# @Last modified by:   archer
# @Last modified time: 2019\-08\-16
# @License: Please see LICENSE in project root

import io
import datetime
from sklearn.datasets import fetch_openml


def main(**kwargs):
    print("downloading mnist dataset...")
    x, y = fetch_openml(\(aqmnist_784\(aq, version=1, return_X_y=True)
    utc_import_start_time = datetime.datetime.utcnow()
    print("importing mnist dataset to mongodb...")
    for i in range(len(x)):  # could use enumerate but only interested in index
        document = {
            "x": x[i].tolist(),     # converting to list to be bson compatible
            "y": int(y[i]),         # Ensuring is num
            "img_num": i,           # saving the image number
            "utc_import_time":  utc_import_start_time,
            "dataset": "mnist",
            "img_count": len(x)
        }
        yield document

.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS Learning
.sp
To learn from the now cleaned database\-residing data, you can:
.INDENT 0.0
.TP
.B section_files\-only learning example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
\&./nemesyst \-\-config ./examples/configs/nemesyst/mnist.conf \-\-dl\-learn
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
This example trains a CNN, and yields a tuple \fB(metadata_dictionary, pickle.dumps(model))\fP which is then stored in \fI\%MongoDB\fP using gridfs as most models exceed the base \fI\%MongoDB\fP 16MB document size limit.
This example is derived from one of the pre\-existing \fI\%Keras\fP \fI\%MNIST\fP examples, but transformed into a relatively efficient Nemesyst variant.
The major differences are that we use \fIfit_generator\fP which takes a generator (in our case a database cursor and pre\-processor) for the training set, and another generator for the validation set. For this example we have simply validated against the test set as we aren’t attempting to blind ourselves for the purposes of scientific rigor and over\-fitting prevention.
Care should be taken in reading the pipelines as they can be quite complex operations to solve very tough problems, but here we simply set them to separate the dataset into train, and validation.
.INDENT 0.0
.TP
.B \fBexamples/learners/mnist_learner.py\fP
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
# @Author: George Onoufriou <archer>
# @Date:   2019\-08\-16
# @Email:  george raven community at pm dot me
# @Filename: mnist_learner.py
# @Last modified by:   archer
# @Last modified time: 2019\-12\-31T17:18:10+00:00
# @License: Please see LICENSE in project root

import numpy as np
import pickle

import keras
from keras import backend as K
from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D


def main(**kwargs):
    """Entry point called by Nemesyst, always yields dictionary or None.

    :param **kwargs: Generic input method to handle infinite dict\-args.
    :rtype: yield dict
    """
    # # there are issues using RTX cards with tensorflow:
    # # https://github.com/tensorflow/tensorflow/issues/24496
    # # if this is the case please uncomment the following two lines:
    import os
    os.environ[\(aqCUDA_VISIBLE_DEVICES\(aq] = \(aq\-1\(aq  # use cpu

    # just making these a little nicer to read but in a real application
    # we would not want these hardcoded thankfully the database can provide!
    args = kwargs["args"]
    db = kwargs["db"]
    img_rows, img_cols = 28, 28
    num_classes = 10
    # creating two database generators to iterate quickly through the data
    # these are not random they will split data using 60000 as the boundary
    train_generator = inf_mnist_generator(db=db, args=args,
                                          example_dim=(img_rows, img_cols),
                                          num_classes=num_classes,
                                          pipeline=[{"$match":
                                                     {"img_num":
                                                      {"$lt": 60000}}}
                                                    ])
    test_generator = inf_mnist_generator(db=db, args=args,
                                         example_dim=(img_rows, img_cols),
                                         num_classes=num_classes,
                                         pipeline=[{"$match":
                                                    {"img_num":
                                                     {"$gte": 60000}}}
                                                   ])
    # ensuring our input shape is in whatever style keras backend wants
    if K.image_data_format() == \(aqchannels_first\(aq:
        input_shape = (1, img_rows, img_cols)
    else:
        input_shape = (img_rows, img_cols, 1)

    model = generate_model(input_shape=input_shape,
                           num_classes=num_classes)
    model.summary()
    hist = model.fit_generator(generator=train_generator,
                               steps_per_epoch=219,  # ceil(70000/32)
                               validation_data=test_generator,
                               validation_steps=219,
                               epochs=args["dl_epochs"][args["process"]],
                               initial_epoch=0)

    excluded_keys = ["pylog", "db_password"]
    # yield metadata, model for gridfs
    best_model = ({
        # metdata dictionary (used to find model later)
        "model": "mnist_example",
        # "validation_loss": float(hist.history["val_loss"][\-1]),
        # "validation_accuracy": float(hist.history["val_acc"][\-1]),
        "loss": float(hist.history["loss"][\-1]),
        "accuracy": float(hist.history["accuracy"][\-1]),
        "args": {k: args[k] for k in set(list(args.keys())) \- \e
                 set(excluded_keys)},
    }, pickle.dumps(model))

    yield best_model


def generate_model(input_shape, num_classes):
    """Generate the keras CNN"""
    model = Sequential()
    model.add(Conv2D(32, kernel_size=(3, 3),
                     activation="relu",
                     input_shape=input_shape))
    model.add(Conv2D(64, (3, 3), activation="relu"))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(0.25))
    model.add(Flatten())
    model.add(Dense(128, activation="relu"))
    model.add(Dropout(0.5))
    model.add(Dense(num_classes, activation="softmax"))

    model.compile(loss=keras.losses.categorical_crossentropy,
                  optimizer=keras.optimizers.Adadelta(),
                  metrics=[\(aqaccuracy\(aq])
    return model


def inf_mnist_generator(db, args, example_dim, num_classes, pipeline=None):
    """Infinite generator of data for keras fit_generator.

    :param db: Mongo() object to use to fetch data.
    :param args: The user provided args and defaults for adaptation.
    :param example_dim: The tuple dimensions of a single example (row, col).
    :param pipeline: The MongoDB aggregate pipeline [{},{},{}] to use.
    :type db: Mongo
    :type args: dict
    :type example_dim: tuple
    :type num_classes: int
    :type pipeline: list(dict())
    :return: Tuple of a single data batch (x_batch,y_batch).
    :rtype: tuple
    """
    # empty pipeline if none provided
    pipeline = pipeline if pipeline is not None else [{"$match": {}}]
    # loop infiniteley over pipeline
    while True:
        c = db.getCursor(db_collection_name=str(args["data_collection"]
                                                [args["process"]]),
                         db_pipeline=pipeline)
        # itetate through the data in batches to minimise requests
        for data_batch in db.getBatches(db_batch_size=args["dl_batch_size"]
                                        [args["process"]], db_data_cursor=c):
            # we recommend you take a quick read of:
            # https://book.pythontips.com/en/latest/map_filter.html
            y = list(map(lambda d: d["y"], data_batch))
            y = np.array(y)  # converting list to numpy ndarray

            x = list(map(lambda d: d["x"], data_batch))
            x = np.array(x)  # converting nlists to ndarray

            # shaping the np array into whatever keras is asking for
            if K.image_data_format() == \(aqchannels_first\(aq:
                y = y.reshape((y.shape[0], 1))
                x = x.reshape((x.shape[0], 1,
                               example_dim[0], example_dim[1]))
                # input_shape = (1, example_dim[0], example_dim[1])
            else:
                y = y.reshape((y.shape[0], 1))
                x = x.reshape((x.shape[0],
                               example_dim[0], example_dim[1], 1))
                # input_shape = (example_dim[0], example_dim[1], 1)

            # normalising to 0\-1
            x = x.astype(\(aqfloat32\(aq)
            x /= 255

            # convert class vectors to binary class matrices
            y = keras.utils.to_categorical(y, num_classes)

            # returning completeley propper data, batch by batch thats all.
            yield x, y

.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS Inferring
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
Work in progress section
.UNINDENT
.UNINDENT
.sp
In this stage we retrieve the model trained previously stored in \fI\%MongoDB\fP as \fI\%gridfs\fP chunks and unpack the model again for reuse and prediction.
We can predict using the \fI\%gridfs\fP stored model by passing:
.INDENT 0.0
.TP
.B section_files\-only inferring example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
\&./nemesyst \-\-config ./examples/configs/nemesyst/mnist.conf \-\-i\-predict
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SH SERVING
.sp
Nemesyst uses \fI\%MongoDB\fP as its primary message passing interface. This page will more elaborate on using Nemesyst with different database setups, debugging, common issues, and any nitty\-gritty details that may be necessary to discuss.
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
While Nemesyst does support using mongodb.yaml files for complex db setup, care should be taken that Nemesyst is not overriding the values you were expecting in the config files. Things such as the DBs path are almost always overridden along with the port to use by default even if the user has not provided that argument. In future we intend to make it such that hard coded defaults when not overridden by the user, first attempt to look in the mongodb.yaml file before falling back to hard\-coded values.
.UNINDENT
.UNINDENT
.SS Creating a basic database
.sp
Disambiguation: we define a basic database as a standalone \fI\%MongoDB\fP instance with one universal administrator and one read/write user with password authentication.
.sp
While it is possible it is highly discouraged to use Nemesyst to create the users you require as this is quite complicated to manage and may lead to more problems than its worth compared to simply creating a database and adding a user manually using something like the following:
.SS Manual creation of \fI\%MongoDB\fP
.INDENT 0.0
.TP
.B section_files\-only creation of database example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
mongod \-\-config ./examples/configs/basic_mongo_config.yaml
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
This will create a database with all the \fI\%MongoDB\fP defaults as it is an empty \fI\%yaml\fP file.
If you would instead want a more complex setup please take a look at \fBexamples/configs/authenticated_replicaset.yaml\fP instead, but you will need to generate certificates and keys for this so it is probably a poor place to start but will be what you will want to use in production as a bare minimum security.
.SS \fI\%Docker\-Compose\fP creation of \fI\%MongoDB\fP
.INDENT 0.0
.TP
.B \fI\%Docker\-Compose\fP, section_files\-only creation of database example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
docker\-compose up
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
This similar to the \fI\%Manual creation of MongoDB\fP creation uses a simple config file to launch the database. This can be changed in \fBdocker\-compose.yaml\fP\&.
At this point you will need to connect to the running \fI\%MongoDB\fP instance (see: \fI\%Connecting to a running database\fP) to create your main administrator user, with “userAdminAnyDatabase” role.
After this you can use the following to close the \fI\%Docker\fP container with the database:
.INDENT 0.0
.TP
.B \fI\%Docker\-Compose\fP, section_files\-only, closing \fI\%Docker\-Compose\fP database example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
docker\-compose down
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Don’t worry we set our docker\-compose.yaml to save its files in \fB/data/db\fP so they are persistent between runs of docker\-compose. If you need to delete the \fI\%MongoDB\fP database that is where you can find them.
.UNINDENT
.UNINDENT
.SS Connecting to a running database
.sp
To be able to fine tune, create users, update etc it will be necessary to connect to \fI\%MongoDB\fP in one form or another. Nemesyst can help you log in or you can do it manually.
.INDENT 0.0
.INDENT 3.5
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
If there is no \fI\%userAdmin or userAdminAnyDatabase\fP then unless expressly configured there will be a localhost exception which will allow you to log in and create this user. If this user exists the localhost exception will close. Please ensure you configure this user as they can grant any role or rights to anyone and would be a major security concern along with making it very difficult to admin your database.
.UNINDENT
.UNINDENT
.UNINDENT
.UNINDENT
.SS Nemesyst
.sp
Nemesyst can be used to log you in to the mongo shell although this feature should not be depended on, and instead it is recommended to use mongo for anything more complicated than simple testing. You will need to provide any other options like ip port etc if it is not using the defaults.
.INDENT 0.0
.TP
.B Bash shell simple all defaults example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
nemesyst \-\-db\-login
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS Mongo
.sp
To connect to an non\-sharded database with autnentication but no TLS/SSL:
.INDENT 0.0
.TP
.B Bash shell example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
mongo HOSTNAME:PORT \-u USERNAME \-\-authenticationDatabase DATABASENAME
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
To connect to a slightly more complicated scenario with authentication, TLS, and sharding enabled:
.INDENT 0.0
.TP
.B Bash shell example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
mongo HOSTNAME:PORT \-u USERNAME \-\-authenticationDatabase DATABASENAME \-\-tls \-\-tlsCAFile PATHTOCAFILE \-\-tlsCertificateKeyFile PATHTOCERTKEYFILE
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS Creating database users
.sp
You will absolutely need a user with at least “userAdminAnyDatabase” role.
Connect to the running database see \fI\%Connecting to a running database\fP\&.
.INDENT 0.0
.TP
.B \fI\%Mongo shell\fP create a new role\-less user:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
db.createUser({user: "USERNAME", pwd: passwordPrompt(), roles: []})
.ft P
.fi
.UNINDENT
.UNINDENT
.TP
.B \fI\%Mongo shell\fP grant role to existing user example:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
db.grantRolesToUser(
"USERNAME",
[
  { role: "userAdminAnyDatabase", db: "admin" }
])
.ft P
.fi
.UNINDENT
.UNINDENT
.TP
.B \fI\%Mongo shell\fP create user and grant userAdminAnyDatabase in one:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
db.createUser({user: "USERNAME", pwd: passwordPrompt(), roles: [{role:"userAdminAnyDatabase", db: "admin"}]})
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
Since this user belongs to admin in the previous examples that means the authenticationDatabase is admin when authenticating as this user as per the instructions in “\fI\%Connecting to a running database\fP”.
.UNINDENT
.UNINDENT
.SS From basic database to replica sets
.INDENT 0.0
.TP
.B todo
Include instructions for turning a database into several replica sets.
.UNINDENT
.SS Troubleshooting
.sp
Please see section_ts_mongodb
.SS Further reading
.sp
\fI\%MongoDB config file options\fP
.SH OPTIONS
.sp
Nemesyst uses \fI\%ConfigArgParse\fP for argument handling.
This means you may pass in arguments as (in order of highest priority first):
.INDENT 0.0
.IP \(bu 2
CLI arguments
.IP \(bu 2
Environment variables
.IP \(bu 2
ini format .conf config files
.IP \(bu 2
Hard\-coded defaults
.UNINDENT
.sp
In code Nemesyst will look for config files in the following default locations, in order of priority and with expansion (highest first):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
def default_config_files():
    """Default config file generator, for cleaner abstraction.

    :return: ordered list of config file expansions
    :rtype: list
    """
    config_files = [
        "./nemesyst.d/*.conf",
        "/etc/nemesyst/nemesyst.d/*.conf",
    ]
    return config_files

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Using the –config argument you may specify more config files, which will be perpended to the default ones in the order supplied. Please note however config file locations are only followed once to avoid infinite loops where two configs point to each other, making Nemesyst read one then the other infinitely.
.SS All Options by Category
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
usage: nemesyst [\-h] [\-U] [\-\-prevent\-update] [\-c CONFIG [CONFIG ...]]
                [\-\-process\-pool PROCESS_POOL] [\-d DATA [DATA ...]] [\-\-data\-clean]
                [\-\-data\-cleaner DATA_CLEANER [DATA_CLEANER ...]]
                [\-\-data\-cleaner\-entry\-point DATA_CLEANER_ENTRY_POINT [DATA_CLEANER_ENTRY_POINT ...]]
                [\-\-data\-collection DATA_COLLECTION [DATA_COLLECTION ...]]
                [\-\-dl\-batch\-size DL_BATCH_SIZE [DL_BATCH_SIZE ...]]
                [\-\-dl\-epochs DL_EPOCHS [DL_EPOCHS ...]] [\-\-dl\-learn]
                [\-\-dl\-learner DL_LEARNER [DL_LEARNER ...]]
                [\-\-dl\-learner\-entry\-point DL_LEARNER_ENTRY_POINT [DL_LEARNER_ENTRY_POINT ...]]
                [\-\-dl\-data\-collection DL_DATA_COLLECTION [DL_DATA_COLLECTION ...]]
                [\-\-dl\-data\-pipeline DL_DATA_PIPELINE [DL_DATA_PIPELINE ...]]
                [\-\-dl\-input\-model\-collection DL_INPUT_MODEL_COLLECTION [DL_INPUT_MODEL_COLLECTION ...]]
                [\-\-dl\-input\-model\-pipeline DL_INPUT_MODEL_PIPELINE [DL_INPUT_MODEL_PIPELINE ...]]
                [\-\-dl\-output\-model\-collection DL_OUTPUT_MODEL_COLLECTION [DL_OUTPUT_MODEL_COLLECTION ...]]
                [\-\-i\-predictor I_PREDICTOR [I_PREDICTOR ...]]
                [\-\-i\-predictor\-entry\-point I_PREDICTOR_ENTRY_POINT [I_PREDICTOR_ENTRY_POINT ...]]
                [\-\-i\-output\-prediction\-collection I_OUTPUT_PREDICTION_COLLECTION [I_OUTPUT_PREDICTION_COLLECTION ...]]
                [\-\-i\-predict] [\-\-db\-replica\-set\-name DB_REPLICA_SET_NAME]
                [\-\-db\-replica\-read\-preference DB_REPLICA_READ_PREFERENCE]
                [\-\-db\-replica\-max\-staleness DB_REPLICA_MAX_STALENESS] [\-\-db\-tls]
                [\-\-db\-tls\-ca\-file DB_TLS_CA_FILE]
                [\-\-db\-tls\-certificate\-key\-file DB_TLS_CERTIFICATE_KEY_FILE]
                [\-\-db\-tls\-certificate\-key\-file\-password DB_TLS_CERTIFICATE_KEY_FILE_PASSWORD]
                [\-\-db\-tls\-crl\-file DB_TLS_CRL_FILE] [\-l] [\-s] [\-S] [\-i]
                [\-\-db\-user\-name DB_USER_NAME] [\-\-db\-password] [\-\-db\-intervention]
                [\-\-db\-authentication DB_AUTHENTICATION]
                [\-\-db\-authentication\-database DB_AUTHENTICATION_DATABASE]
                [\-\-db\-user\-role DB_USER_ROLE] [\-\-db\-ip DB_IP]
                [\-\-db\-bind\-ip DB_BIND_IP [DB_BIND_IP ...]] [\-\-db\-port DB_PORT]
                [\-\-db\-name DB_NAME] [\-\-db\-collection\-name DB_COLLECTION_NAME]
                [\-\-db\-config\-path DB_CONFIG_PATH] [\-\-db\-path DB_PATH]
                [\-\-db\-log\-path DB_LOG_PATH] [\-\-db\-log\-name DB_LOG_NAME]
                [\-\-db\-cursor\-timeout DB_CURSOR_TIMEOUT] [\-\-db\-batch\-size DB_BATCH_SIZE]
                [\-\-db\-pipeline DB_PIPELINE]
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Nemesyst options
.INDENT 0.0
.TP
.B\-U, \-\-update
Nemesyst update, and restart.
.sp
Default: False
.TP
.B\-\-prevent\-update
Prevent nemesyst from updating.
.sp
Default: False
.TP
.B\-c, \-\-config
List of all ini files to be used.
.sp
Default: []
.TP
.B\-\-process\-pool
The maximum number of processes to allocate.
.sp
Default: 1
.UNINDENT
.SS Data pre\-processing options
.INDENT 0.0
.TP
.B\-d, \-\-data
List of data file paths.
.sp
Default: []
.TP
.B\-\-data\-clean
Clean specified data files.
.sp
Default: False
.TP
.B\-\-data\-cleaner
Path to data cleaner(s).
.sp
Default: []
.TP
.B\-\-data\-cleaner\-entry\-point
Specify the entry point of custom scripts to use.
.sp
Default: [‘main’]
.TP
.B\-\-data\-collection
Specify data storage collection name(s).
.sp
Default: [‘debug_data’]
.UNINDENT
.SS Deep learning options
.INDENT 0.0
.TP
.B\-\-dl\-batch\-size
Batch size of the data to use.
.sp
Default: [32]
.TP
.B\-\-dl\-epochs
Number of epochs to train on data.
.sp
Default: [1]
.TP
.B\-\-dl\-learn
Use learner scripts.
.sp
Default: False
.TP
.B\-\-dl\-learner
Path to learner(s).
.sp
Default: []
.TP
.B\-\-dl\-learner\-entry\-point
Specify the entry point of custom scripts to use.
.sp
Default: [‘main’]
.TP
.B\-\-dl\-data\-collection
Specify data collection name(s).
.sp
Default: [‘debug_data’]
.TP
.B\-\-dl\-data\-pipeline
Specify pipeline(s) for data retrieval.
.sp
Default: [{}]
.TP
.B\-\-dl\-input\-model\-collection
Specify model storage collection to retrain from.
.sp
Default: [‘debug_models’]
.TP
.B\-\-dl\-input\-model\-pipeline
Specify model storage collection to retrain from.
.sp
Default: [{}]
.TP
.B\-\-dl\-output\-model\-collection
Specify model storage collection to post trained neural networks to.
.sp
Default: [‘debug_models’]
.UNINDENT
.SS Infering options
.INDENT 0.0
.TP
.B\-\-i\-predictor
Path to predictor(s).
.sp
Default: []
.TP
.B\-\-i\-predictor\-entry\-point
Specify the entry point of predictor custom scripts to use.
.sp
Default: [‘main’]
.TP
.B\-\-i\-output\-prediction\-collection
Specify prediction storage collection to post trained neural network predictions to.
.sp
Default: [‘debug_predictions’]
.TP
.B\-\-i\-predict
Use predictor/ inferer scripts.
.sp
Default: False
.UNINDENT
.SS MongoDb replica options
.INDENT 0.0
.TP
.B\-\-db\-replica\-set\-name
Set the name for the replica set to use.
.TP
.B\-\-db\-replica\-read\-preference
Set the read preference of mongo client.
.sp
Default: “primary”
.TP
.B\-\-db\-replica\-max\-staleness
Max seconds replica can be out of sync.
.sp
Default: \-1
.UNINDENT
.SS MongoDb TLS options
.INDENT 0.0
.TP
.B\-\-db\-tls
Set connection to mongodb use TLS.
.sp
Default: False
.TP
.B\-\-db\-tls\-ca\-file
Certificat\-authority certificate path.
.TP
.B\-\-db\-tls\-certificate\-key\-file
Clients certificate and key pem path.
.TP
.B\-\-db\-tls\-certificate\-key\-file\-password
Set pass if certkey file needs password.
.TP
.B\-\-db\-tls\-crl\-file
Path to certificate revocation list file.
.UNINDENT
.SS MongoDb options
.INDENT 0.0
.TP
.B\-l, \-\-db\-login
Nemesyst log into mongodb.
.sp
Default: False
.TP
.B\-s, \-\-db\-start
Nemesyst launch mongodb.
.sp
Default: False
.TP
.B\-S, \-\-db\-stop
Nemesyst stop mongodb.
.sp
Default: False
.TP
.B\-i, \-\-db\-init
Nemesyst initialise mongodb files.
.sp
Default: False
.TP
.B\-\-db\-user\-name
Set mongodb username.
.TP
.B\-\-db\-password
Set mongodb password.
.sp
Default: False
.TP
.B\-\-db\-intervention
Manual intervention during database setup.
.sp
Default: False
.TP
.B\-\-db\-authentication
Set the mongodb authentication method.
.sp
Default: “SCRAM\-SHA\-1”
.TP
.B\-\-db\-authentication\-database
Override db_name as database to authenticate.
.TP
.B\-\-db\-user\-role
Set the users permissions in the database.
.sp
Default: “readWrite”
.TP
.B\-\-db\-ip
The ip of the database to connect to.
.sp
Default: “localhost”
.TP
.B\-\-db\-bind\-ip
The ip the database should be accessible from.
.sp
Default: [‘localhost’]
.TP
.B\-\-db\-port
The port both the unauth and auth db will use.
.sp
Default: “65535”
.TP
.B\-\-db\-name
The name of the authenticated database.
.sp
Default: “nemesyst”
.TP
.B\-\-db\-collection\-name
The name of the collection to use in database.
.sp
Default: “test”
.TP
.B\-\-db\-config\-path
The path to the mongodb configuration file.
.TP
.B\-\-db\-path
The parent directory to use for the database.
.sp
Default: /home/archer/db
.TP
.B\-\-db\-log\-path
The parent directory to use for the db log.
.sp
Default: /home/archer/db/log
.TP
.B\-\-db\-log\-name
The base name of the log file to maintain.
.sp
Default: “mongo_log”
.TP
.B\-\-db\-cursor\-timeout
The duration in seconds before an unused cursor will time out.
.sp
Default: 600000
.TP
.B\-\-db\-batch\-size
The number of documents to return from the db at once/ pre round.
.sp
Default: 32
.TP
.B\-\-db\-pipeline
The file path of the pipeline to use on db.
.UNINDENT
.SH MONGO
.sp
Nemesyst MongoDB abstraction/ Handler.
This handler helps abstract some pymongo functionality to make it easier for us to use a MongoDB database for our deep learning purposes.
.SS Example usage
.sp
Below follows a in code example unit test for all functionality. You can overide the options using a dictionary to the constructor or as keyword arguments to the functions that use them:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
def _mongo_unit_test():
    """Unit test of MongoDB compat."""
    import datetime
    # create Mongo object to use
    db = Mongo({"test2": 2, "db_port": "65535"})
    # testing magic functions
    db["test2"] = 3  # set item
    db["test2"]  # get item
    len(db)  # len
    del db["test2"]  # del item
    # output current state of Mongo
    db.debug()
    # stop any active databases already running at the db path location
    db.stop()
    # hold for 2 seconds to give the db time to start
    time.sleep(2)
    # attempt to initialise the database, as in create the database with users
    db.init()
    # hold to let the db to launch the now new unauthenticated db
    time.sleep(2)
    # start the authenticated db, you will now need a username password access
    db.start()
    # warm up time for new authentication db
    time.sleep(2)
    # create a connection to the database so we can do database operations
    db.connect()
    db.debug()
    # import data into mongodb debug collection
    db.dump(db_collection_name="test", data={
        "string": "99",
        "number": 99,
        "binary": bin(99),
        "subdict": {"hello": "world"},
        "subarray": [{"hello": "worlds"}, {"hi": "jim"}],
        "timedate": datetime.datetime.utcnow(),
    })
    # log into the database so user can manually check data import
    db.login()
    # attempt to retrieve the data that exists in the collection as a cursor
    db.getCursor(db_collection_name="test", db_pipeline=[{"$match": {}}])
    # itetate through the data in batches to minimise requests
    for dataBatch in db.getBatches(db_batch_size=32):
        print("Returned number of documents:", len(dataBatch))
    # finally close out database
    db.stop()

.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
Mongo uses subprocess.Popen in init, start, and stop, since these threads would otherwise lock up nemesyst, with time.sleep() to wait for the database to startup, and shutdown. Depending on the size of your database it may be necessary to extend the length of time time.sleep() as larger databases will take longer to startup and shutdown.
.UNINDENT
.UNINDENT
.SS API
.INDENT 0.0
.TP
.B class mongo.Mongo(args: dict = None, logger: print = None)
Python2/3 compatible MongoDb utility wrapper.
.sp
This wrapper saves its state in an internal overridable dictionary
such that you can adapt it to your requirements, if you should need to do
something unique, the caveat being it becomes harder to read.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBargs\fP (\fIdictionary\fP) – Dictionary of overides.
.IP \(bu 2
\fBlogger\fP (\fIfunction address\fP) – Function address to print/ log to (default: print).
.UNINDENT
.TP
.B Example
Mongo({“db_user_name”: “someUsername”,
“db_password”: “somePassword”})
.TP
.B Example
Mongo()
.UNINDENT
.INDENT 7.0
.TP
.B connect(db_ip: str = None, db_port: str = None, db_authentication: str = None, db_authentication_database=None, db_user_name: str = None, db_password: str = None, db_name: str = None, db_replica_set_name: str = None, db_replica_read_preference: str = None, db_replica_max_staleness: str = None, db_tls: bool = None, db_tls_ca_file: str = None, db_tls_certificate_key_file: str = None, db_tls_certificate_key_file_password: str = None, db_tls_crl_file: str = None, db_collection_name: str = None) -> pymongo.database.Database
Connect to a specific mongodb database.
.sp
This sets the internal db client which is neccessary to connect to
and use the associated database. Without it operations such as dump
into the database will fail. This is replica set capable.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdb_ip\fP (\fIstring\fP) – Database hostname or ip to connect to.
.IP \(bu 2
\fBdb_port\fP (\fIstring\fP) – Database port to connect to.
.IP \(bu 2
\fBdb_authentication\fP (\fIstring\fP) – The authentication method to use on db.
.IP \(bu 2
\fBdb_user_name\fP (\fIstring\fP) – Username to use for authentication to db_name.
.IP \(bu 2
\fBdb_password\fP (\fIstring\fP) – Password for db_user_name in database db_name.
.IP \(bu 2
\fBdb_name\fP (\fIstring\fP) – The name of the database to connect to.
.IP \(bu 2
\fBdb_replica_set_name\fP (\fIstring\fP) – Name of the replica set to connect to.
.IP \(bu 2
\fBdb_replica_read_preference\fP (\fIstring\fP) – What rep type to prefer reads from.
.IP \(bu 2
\fBdb_replica_max_staleness\fP (\fIstring\fP) – Max seconds behind is replica allowed.
.IP \(bu 2
\fBdb_tls\fP (\fIbool\fP) – use TLS for db connection.
.IP \(bu 2
\fBdb_tls_certificate_key_file\fP (\fIstring\fP) – Certificate and key file for tls.
.IP \(bu 2
\fBdb_tls_certificate_key_file_password\fP (\fIstring\fP) – Cert and key file pass.
.IP \(bu 2
\fBdb_tls_crl_file\fP (\fIstring\fP) – Certificate revocation list file path.
.IP \(bu 2
\fBdb_collection_name\fP (\fIstring\fP) – GridFS collection to use.
.UNINDENT
.TP
.B Returns
database client object
.TP
.B Return type
pymongo.database.Database
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B debug() -> None
Log function to help track the internal state of the class.
.sp
Simply logs working state of args dict.
.UNINDENT
.INDENT 7.0
.TP
.B dump(db_collection_name: str, data: dict, db: pymongo.database.Database = None) -> None
Import data dictionary into database.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdb_collection_name\fP (\fIstring\fP) – Collection name to import into.
.IP \(bu 2
\fBdata\fP (\fIdictionary\fP) – Data to import into database.
.IP \(bu 2
\fBdb\fP (\fIpymongo.database.Database\fP) – Database to import data into.
.UNINDENT
.TP
.B Example
dump(db_collection_name=”test”,
data={“subdict”:{“hello”: “world”}})
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B getBatches(db_batch_size: int = None, db_data_cursor: pymongo.command_cursor.CommandCursor = None) -> list
Get database cursor data in batches.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdb_batch_size\fP (\fIinteger\fP) – The number of items to return in a single round.
.IP \(bu 2
\fBdb_data_cursor\fP (\fIcommand_cursor.CommandCursor\fP) – The cursor to use to retrieve data from db.
.UNINDENT
.TP
.B Returns
yields a list of items requested.
.TP
.B Return type
list of dicts
.TP
.B Todo
desperateley needs a rewrite and correction of bug. Last value
always fails. I want this in a magic function too to make it easy.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B getCursor(db: pymongo.database.Database = None, db_pipeline: list = None, db_collection_name: str = None) -> pymongo.command_cursor.CommandCursor
Use aggregate pipeline to get a data\-cursor from the database.
.sp
This cursor is what mongodb provides to allow you to request the data
from the database in a manner you control, instead of just getting
a big dump from the database.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdb_pipeline\fP (\fIlist of dicts\fP) – Mongodb aggregate pipeline data to transform and
retrieve the data as you request.
.IP \(bu 2
\fBdb_collection_name\fP (\fIstr\fP) – The collection name which we will pull data
from using the aggregate pipeline.
.IP \(bu 2
\fBdb\fP (\fIpymongo.database.Database\fP) – Database object to operate pipeline on.
.UNINDENT
.TP
.B Returns
Command cursor to fetch the data with.
.TP
.B Return type
pymongo.command_cursor.CommandCursor
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B init(db_path: str = None, db_log_path: str = None, db_log_name: str = None, db_config_path: str = None) -> None
Initialise the database.
.sp
Includes ensuring db path and db log path exist and generating,
creating the DB files, and adding an authentication user.
All of this should be done on a localhost port so that the
unprotected database is never exposed.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdb_path\fP (\fIstring\fP) – Desired directory of MongoDB database files.
.IP \(bu 2
\fBdb_log_path\fP (\fIstring\fP) – Desired directory of MongoDB log files.
.IP \(bu 2
\fBdb_log_name\fP (\fIstring\fP) – Desired name of log file.
.IP \(bu 2
\fBdb_config_path\fP (\fIstring\fP) – Config file to pass to MongoDB.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B login(db_port: str = None, db_user_name: str = None, db_password: str = None, db_name: str = None, db_ip: str = None) -> None
Log in to database, interrupt, and availiable via cli.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdb_port\fP (\fIstring\fP) – Database port to connect to.
.IP \(bu 2
\fBdb_user_name\fP (\fIstring\fP) – Database user to authenticate as.
.IP \(bu 2
\fBdb_password\fP (\fIstring\fP) – User password to authenticate with.
.IP \(bu 2
\fBdb_name\fP (\fIstring\fP) – Database to authenticate to, the authentication db.
.IP \(bu 2
\fBdb_ip\fP (\fIstring\fP) – Database ip to connect to.
.UNINDENT
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B start(db_ip: str = None, db_port: str = None, db_path: str = None, db_log_path: str = None, db_log_name: str = None, db_cursor_timeout: int = None, db_config_path: str = None, db_replica_set_name: str = None) -> subprocess.Popen
Launch an on machine database with authentication.
.INDENT 7.0
.TP
.B Parameters
.INDENT 7.0
.IP \(bu 2
\fBdb_ip\fP (\fIlist\fP) – List of IPs to accept connectiongs from.
.IP \(bu 2
\fBdb_port\fP (\fIstring\fP) – Port desired for database.
.IP \(bu 2
\fBdb_path\fP (\fIstring\fP) – Path to parent dir of database.
.IP \(bu 2
\fBdb_log_path\fP (\fIstring\fP) – Path to parent dir of log files.
.IP \(bu 2
\fBdb_log_name\fP (\fIstring\fP) – Desired base name for log files.
.IP \(bu 2
\fBdb_cursor_timeout\fP (\fIinteger\fP) – Set timeout time for unused cursors.
.IP \(bu 2
\fBdb_path\fP – Config file path to pass to MongoDB.
.UNINDENT
.TP
.B Return type
subprocess.Popen
.TP
.B Returns
Subprocess of running MongoDB.
.UNINDENT
.UNINDENT
.INDENT 7.0
.TP
.B stop(db_path=None) -> subprocess.Popen
Stop a running local database.
.INDENT 7.0
.TP
.B Parameters
\fBdb_path\fP (\fIstring\fP) – The path to the database to shut down.
.TP
.B Returns
Subprocess of database closer.
.TP
.B Return type
subprocess.Popen
.UNINDENT
.UNINDENT
.UNINDENT
.SH DOCKERISATION
.sp
Docker is a lightweight semi\-vm that can help automate reproducibility, dependency management, deployment, and use of some code which is containerized.
Considering the relative ease with which Docker is used, modified/adjusted, with only a minimal amount of code, it has quite a profound affect on work\-flows, making really nightmarish scenarios much easier to handle.
.sp
For docker installation you may need to look up instructions online but after installing docker (minimum version 19.03) and nvidia container toolkit, you will need not install anything further, and can instead rely on the Dockerfile and docker to install and manage dependencies from then on. If you would like more automation/ to use docker\-compose then please ensure you also have docker\-compose installed.
.sp
There are two available versions of our Dockerfile:
.INDENT 0.0
.IP \(bu 2
Archlinux based nemesyst docker \fBexamples/containers/nemesyst/Dockerfile\fP; This docker is the one we seek to support since it will force us to stay up to date with the latest software and changes so we never end up in a crippling dependency requirement. It should be noted however that it is not quite complete.
.IP \(bu 2
Ubuntu based nemesyst docker \fBexamples/containers/nemesyst_ubuntu/Dockerfile\fP; This docker is the one we make available for the purposes of longer term support, and for those that just prefer Ubuntu (you must be crazy!). This one is the more supported by depended on projects such as tf\-seal so is easier to maintain.
.UNINDENT
.SS Docker Usage (Linux)
.sp
While docker is very portable to most platforms, we do not maintain any non\-x86_64, Microsoft Windows or Mac systems, thus we cannot presume to give sound Docker usage on these other platforms. However the usage should largely remain the same, but presumably without the need for privilege escalation using sudo for Win and Mac.
.sp
Using docker usually revolves around only two steps building the image you would like to use, and then using it either interactively or by issuing explicit commands to be executed. First however we should briefly mention the two most important files related to this a .dockerignore file, and a \fI\%Dockerfile\fP .
.SS \fI\%Dockerfile\fP
.sp
A \fI\%Dockerfile\fP is a short command based script that defines how to create a container. These can and usually are built on other containers. Please refer to the \fI\%Dockerfile\fP documentation for a more in depth breakdown.
.INDENT 0.0
.TP
.B \fI\%Dockerfile\fP example \fBexamples/containers/nemesyst_ubuntu/Dockerfile\fP
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
FROM ubuntu:19.04

# updating and installing basic ubuntu python container
RUN apt update && \e
    apt install \-y wget python3.7 python3\-pip git

# getting and installing tensorflow, and tf\-seal
RUN wget https://storage.googleapis.com/tf\-pips/tf\-c++17\-support/tf_nightly\-1.14.0\-cp37\-cp37m\-linux_x86_64.whl && \e
    python3.7 \-m pip install tf_nightly\-1.14.0\-cp37\-cp37m\-linux_x86_64.whl && \e
    rm tf_nightly\-1.14.0\-cp37\-cp37m\-linux_x86_64.whl && \e
    python3.7 \-m pip install tf\-seal

# getting tf\-seal repository so we have access to all of their examples etc
RUN python3.7 \-m pip install git+https://github.com/DreamingRaven/nemesyst.git#branch=master && \e
    git clone https://github.com/tf\-encrypted/tf\-seal && \e
    git clone https://github.com/DreamingRaven/nemesyst

.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS \&.dockerignore
.sp
A .dockerignore is similar in function to a .gitignore and supports similar syntax. Special care should be paid to .dockerignore files as they are both useful to minimise the risk of potential secrets being leaked into a container, their container size etc, but they can also cause problems with things like the \fB\(gaCOPY\(ga\fP command leading to unexpected results. We personally recommend a whitelist strategy .dockerignore where you specify only what you would like to be copied in.
.INDENT 0.0
.TP
.B whitelist .dockerignore example \fBexamples/containers/nemesyst_ubuntu/.dockerignore\fP
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
# ignore everything using whitelist strategy
*

# you can selectiveley allow files using the ! at the beginning of the line
#!lib/**/*.py # this would allow all python files in subdirectories of lib if enabled

.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS Building
.sp
With a \fI\%Dockerfile\fP in the current directory to build a dockerfile into a docker image:
.INDENT 0.0
.TP
.B \fI\%Bash shell\fP creating a tagged docker image
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
sudo docker build \-t example/nemesyst .
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
This tag “example/nemesyst” will help you reference the docker image later on, like easy removal, and general use.
.SS Running
.sp
When we take a built image and run it, it is now called a container. Images are the immutable snapshots that you have built, containers are the changed containers for all the work that has happened since being an image.
.sp
To create a container from an image/ to run a docker image you can either:
.INDENT 0.0
.TP
.B \fI\%Bash shell\fP creating/running a CPU only container from a tagged (“example/nemesyst”) docker image
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
sudo docker run \-it example/nemesyst bash
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.sp
or
.INDENT 0.0
.TP
.B \fI\%Bash shell\fP creating/running a GPU enabled container (“example/nemesyst”)
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
sudo docker run \-\-gpus all \-it example/nemesyst bash
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SS Cleaning up/ Removing
.sp
It may be necessary over the course of any experimentation or creation to occasionally clean up any images and containers that may still be taking up space on your system.
.INDENT 0.0
.TP
.B \fI\%Bash shell\fP removing/ pruning everything
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
sudo docker system prune
.ft P
.fi
.UNINDENT
.UNINDENT
.TP
.B \fI\%Bash shell\fP removing all images
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
sudo docker rmi \-f $(sudo docker images \-q)
.ft P
.fi
.UNINDENT
.UNINDENT
.TP
.B \fI\%Bash shell\fP removing all containers
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
sudo docker rm (sudo docker ps \-a \-q)
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.SH TROUBLESHOOTING
.SS MongoDB/ Serving Issues
.INDENT 0.0
.TP
.B Error: not master and slaveOk=false
This error means you have attempted to read from a replica set that is not the master. If you would like to read from SECONDARY\-ies/ slaves (anything thats not the PRIMARY) you can:
.INDENT 7.0
.TP
.B Mongo shell:
.INDENT 7.0
.INDENT 3.5
.sp
.nf
.ft C
\fI\%rs.slaveOk()\fP
.ft P
.fi
.UNINDENT
.UNINDENT
.UNINDENT
.TP
.B pymongo.errors.OperationFailure: Authentication failed
This error means likely means that your authentication credentials are incorrect, you will want to check the values you are passing to pymongo via Nemesyst to ensure they are what you are expecting. In particular pay special attention to Mongo().connect() as it is the life blood of all connections but since the driver is a lazy driver it wont fail until you attempt to use the connection.
.UNINDENT
.SH AUTHOR
GeorgeRaven
.SH COPYRIGHT
2017, George Onoufriou (GeorgeRaven, archer, DreamingRaven)
.\" Generated by docutils manpage writer.
.
